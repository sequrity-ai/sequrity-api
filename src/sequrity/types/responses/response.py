"""Pydantic models for OpenAI Responses API response types."""

from __future__ import annotations

from typing import Annotated, Any, Literal

from pydantic import BaseModel, ConfigDict, Field

# =============================================================================
# Output Content Types
# =============================================================================


class OutputTextLogprobTopLogprob(BaseModel):
    token: str = Field(..., description="The token.")
    bytes: list[int] = Field(..., description="A list of integers representing the UTF-8 bytes of the token.")
    logprob: float = Field(..., description="The log probability of the token.")


class OutputTextLogprob(BaseModel):
    token: str = Field(..., description="The token.")
    bytes: list[int] = Field(..., description="A list of integers representing the UTF-8 bytes of the token.")
    logprob: float = Field(..., description="The log probability of the token.")
    top_logprobs: list[OutputTextLogprobTopLogprob] = Field(
        ..., description="List of the most likely tokens and their log probability."
    )


class AnnotationFileCitation(BaseModel):
    file_id: str = Field(..., description="The ID of the file.")
    filename: str = Field(..., description="The filename of the file cited.")
    index: int = Field(..., description="The index of the file in the list of files.")
    type: Literal["file_citation"] = Field(..., description="Always 'file_citation'.")


class AnnotationURLCitation(BaseModel):
    end_index: int = Field(..., description="The index of the last character of the URL citation.")
    start_index: int = Field(..., description="The index of the first character of the URL citation.")
    title: str = Field(..., description="The title of the web resource.")
    type: Literal["url_citation"] = Field(..., description="Always 'url_citation'.")
    url: str = Field(..., description="The URL of the web resource.")


class AnnotationContainerFileCitation(BaseModel):
    container_id: str = Field(..., description="The ID of the container.")
    end_index: int = Field(..., description="The index of the last character of the citation.")
    file_id: str = Field(..., description="The ID of the file.")
    filename: str = Field(..., description="The filename of the container file cited.")
    start_index: int = Field(..., description="The index of the first character of the citation.")
    type: Literal["container_file_citation"] = Field(..., description="Always 'container_file_citation'.")


class AnnotationFilePath(BaseModel):
    file_id: str = Field(..., description="The ID of the file.")
    index: int = Field(..., description="The index of the file in the list of files.")
    type: Literal["file_path"] = Field(..., description="Always 'file_path'.")


Annotation = Annotated[
    AnnotationFileCitation | AnnotationURLCitation | AnnotationContainerFileCitation | AnnotationFilePath,
    Field(discriminator="type"),
]


class OutputText(BaseModel):
    type: Literal["output_text"] = Field(..., description="The type of the output content.")
    text: str = Field(..., description="The text content.")
    annotations: list[Annotation] = Field(default_factory=list, description="Annotations for the text.")
    logprobs: list[OutputTextLogprob] | None = Field(default=None, description="Log probability information.")


class Refusal(BaseModel):
    type: Literal["refusal"] = Field(..., description="The type of the output content.")
    refusal: str = Field(..., description="The refusal message generated by the model.")


OutputContentItem = Annotated[
    OutputText | Refusal,
    Field(discriminator="type"),
]

# =============================================================================
# Output Message Type
# =============================================================================


class ResponseOutputMessage(BaseModel):
    id: str = Field(..., description="The unique ID of the output message.")
    type: Literal["message"] = Field(..., description="The type of the output item.")
    role: Literal["assistant"] = Field(..., description="The role of the message. Always 'assistant'.")
    content: list[OutputContentItem] = Field(..., description="The content items of the message.")
    status: Literal["in_progress", "completed", "incomplete"] = Field(..., description="The status of the message.")


# =============================================================================
# Reasoning Item
# =============================================================================


class ReasoningSummary(BaseModel):
    text: str = Field(..., description="A summary of the reasoning output.")
    type: Literal["summary_text"] = Field(..., description="Always 'summary_text'.")


class ReasoningContent(BaseModel):
    text: str = Field(..., description="The reasoning text from the model.")
    type: Literal["reasoning_text"] = Field(..., description="Always 'reasoning_text'.")


class ReasoningItem(BaseModel):
    id: str = Field(..., description="The unique identifier of the reasoning content.")
    type: Literal["reasoning"] = Field(..., description="The type of the output item.")
    summary: list[ReasoningSummary] = Field(default_factory=list, description="Reasoning summary content.")
    content: list[ReasoningContent] | None = Field(default=None, description="Reasoning text content.")
    encrypted_content: str | None = Field(default=None, description="Encrypted content for multi-turn.")
    status: Literal["in_progress", "completed", "incomplete"] | None = Field(
        default=None, description="The status of the reasoning item."
    )


# =============================================================================
# Tool Call Types
# =============================================================================


class FunctionToolCall(BaseModel):
    type: Literal["function_call"] = Field(..., description="The type of the tool call.")
    call_id: str = Field(..., description="The unique ID of the function tool call generated by the model.")
    name: str = Field(..., description="The name of the function to call.")
    arguments: str = Field(..., description="The arguments to call the function with, as a JSON string.")
    id: str | None = Field(default=None, description="The unique ID of the function tool call.")
    status: Literal["in_progress", "completed", "incomplete"] | None = Field(
        default=None, description="The status of the tool call."
    )


class FileSearchResult(BaseModel):
    attributes: dict[str, str | float | bool] | None = Field(default=None, description="Metadata key-value pairs.")
    file_id: str | None = Field(default=None, description="The unique ID of the file.")
    filename: str | None = Field(default=None, description="The name of the file.")
    score: float | None = Field(default=None, description="The relevance score of the file (0-1).")
    text: str | None = Field(default=None, description="The text that was retrieved from the file.")


class FileSearchToolCall(BaseModel):
    type: Literal["file_search_call"] = Field(..., description="The type of the tool call.")
    id: str = Field(..., description="The unique ID of the file search tool call.")
    queries: list[str] = Field(default_factory=list, description="The queries used to search for files.")
    status: Literal["in_progress", "searching", "completed", "incomplete", "failed"] = Field(
        ..., description="The status of the tool call."
    )
    results: list[FileSearchResult] | None = Field(default=None, description="The results of the file search.")


# --- Web Search ---


class WebSearchActionSource(BaseModel):
    type: Literal["url"] = Field(..., description="Always 'url'.")
    url: str = Field(..., description="The URL of the source.")


class WebSearchActionSearch(BaseModel):
    query: str = Field(..., description="The search query.")
    type: Literal["search"] = Field(..., description="The action type.")
    queries: list[str] | None = Field(default=None, description="The search queries.")
    sources: list[WebSearchActionSource] | None = Field(default=None, description="The sources used.")


class WebSearchActionOpenPage(BaseModel):
    type: Literal["open_page"] = Field(..., description="The action type.")
    url: str = Field(..., description="The URL opened by the model.")


class WebSearchActionFind(BaseModel):
    pattern: str = Field(..., description="The pattern or text to search for within the page.")
    type: Literal["find"] = Field(..., description="The action type.")
    url: str = Field(..., description="The URL of the page searched.")


WebSearchAction = Annotated[
    WebSearchActionSearch | WebSearchActionOpenPage | WebSearchActionFind,
    Field(discriminator="type"),
]


class WebSearchToolCall(BaseModel):
    type: Literal["web_search_call"] = Field(..., description="The type of the tool call.")
    id: str = Field(..., description="The unique ID of the web search tool call.")
    action: WebSearchAction | None = Field(default=None, description="The action taken.")
    status: Literal["in_progress", "searching", "completed", "failed"] = Field(
        ..., description="The status of the tool call."
    )


# --- Code Interpreter ---


class CodeInterpreterOutputLogs(BaseModel):
    logs: str = Field(..., description="The logs output from the code interpreter.")
    type: Literal["logs"] = Field(..., description="Always 'logs'.")


class CodeInterpreterOutputImage(BaseModel):
    type: Literal["image"] = Field(..., description="Always 'image'.")
    url: str = Field(..., description="The URL of the image output.")


CodeInterpreterOutput = Annotated[
    CodeInterpreterOutputLogs | CodeInterpreterOutputImage,
    Field(discriminator="type"),
]


class CodeInterpreterToolCall(BaseModel):
    type: Literal["code_interpreter_call"] = Field(..., description="The type of the tool call.")
    id: str = Field(..., description="The unique ID of the code interpreter tool call.")
    code: str | None = Field(default=None, description="The code that was executed.")
    container_id: str = Field(..., description="The ID of the container used to run the code.")
    outputs: list[CodeInterpreterOutput] | None = Field(
        default=None, description="The outputs from the code execution."
    )
    status: Literal["in_progress", "completed", "incomplete", "interpreting", "failed"] | None = Field(
        default=None, description="The status of the tool call."
    )


# --- Computer ---


class ComputerActionClick(BaseModel):
    button: Literal["left", "right", "wheel", "back", "forward"] = Field(
        ..., description="Which mouse button was pressed."
    )
    type: Literal["click"] = Field(..., description="Always 'click'.")
    x: int = Field(..., description="The x-coordinate.")
    y: int = Field(..., description="The y-coordinate.")


class ComputerActionDoubleClick(BaseModel):
    type: Literal["double_click"] = Field(..., description="Always 'double_click'.")
    x: int = Field(..., description="The x-coordinate.")
    y: int = Field(..., description="The y-coordinate.")


class ComputerActionDragPath(BaseModel):
    x: int = Field(..., description="The x-coordinate.")
    y: int = Field(..., description="The y-coordinate.")


class ComputerActionDrag(BaseModel):
    path: list[ComputerActionDragPath] = Field(..., description="Coordinates representing the drag path.")
    type: Literal["drag"] = Field(..., description="Always 'drag'.")


class ComputerActionKeypress(BaseModel):
    keys: list[str] = Field(..., description="The combination of keys to press.")
    type: Literal["keypress"] = Field(..., description="Always 'keypress'.")


class ComputerActionMove(BaseModel):
    type: Literal["move"] = Field(..., description="Always 'move'.")
    x: int = Field(..., description="The x-coordinate.")
    y: int = Field(..., description="The y-coordinate.")


class ComputerActionScreenshot(BaseModel):
    type: Literal["screenshot"] = Field(..., description="Always 'screenshot'.")


class ComputerActionScroll(BaseModel):
    scroll_x: int = Field(..., description="The horizontal scroll distance.")
    scroll_y: int = Field(..., description="The vertical scroll distance.")
    type: Literal["scroll"] = Field(..., description="Always 'scroll'.")
    x: int = Field(..., description="The x-coordinate.")
    y: int = Field(..., description="The y-coordinate.")


class ComputerActionType(BaseModel):
    text: str = Field(..., description="The text to type.")
    type: Literal["type"] = Field(..., description="Always 'type'.")


class ComputerActionWait(BaseModel):
    type: Literal["wait"] = Field(..., description="Always 'wait'.")


ComputerAction = Annotated[
    ComputerActionClick
    | ComputerActionDoubleClick
    | ComputerActionDrag
    | ComputerActionKeypress
    | ComputerActionMove
    | ComputerActionScreenshot
    | ComputerActionScroll
    | ComputerActionType
    | ComputerActionWait,
    Field(discriminator="type"),
]


class ComputerPendingSafetyCheck(BaseModel):
    id: str = Field(..., description="The ID of the pending safety check.")
    code: str | None = Field(default=None, description="The type of the pending safety check.")
    message: str | None = Field(default=None, description="Details about the pending safety check.")


class ComputerToolCall(BaseModel):
    type: Literal["computer_call"] = Field(..., description="The type of the tool call.")
    id: str = Field(..., description="The unique ID of the computer call.")
    action: ComputerAction = Field(..., description="The action performed by the computer tool.")
    call_id: str = Field(..., description="An identifier used when responding to the tool call with output.")
    pending_safety_checks: list[ComputerPendingSafetyCheck] = Field(
        default_factory=list, description="The pending safety checks."
    )
    status: Literal["in_progress", "completed", "incomplete"] = Field(..., description="The status of the tool call.")


# --- Image Generation ---


class ImageGenerationCall(BaseModel):
    type: Literal["image_generation_call"] = Field(..., description="The type of the output item.")
    id: str = Field(..., description="The unique ID of the image generation call.")
    result: str | None = Field(default=None, description="The generated image encoded in base64.")
    status: Literal["in_progress", "completed", "generating", "failed"] = Field(
        ..., description="The status of the image generation call."
    )


# --- Local Shell ---


class LocalShellCallAction(BaseModel):
    command: list[str] = Field(..., description="The command to run.")
    env: dict[str, str] = Field(default_factory=dict, description="Environment variables.")
    type: Literal["exec"] = Field(..., description="Always 'exec'.")
    timeout_ms: int | None = Field(default=None, description="Optional timeout in milliseconds.")
    user: str | None = Field(default=None, description="Optional user to run the command as.")
    working_directory: str | None = Field(default=None, description="Optional working directory.")


class LocalShellCall(BaseModel):
    type: Literal["local_shell_call"] = Field(..., description="The type of the output item.")
    id: str = Field(..., description="The unique ID of the local shell call.")
    action: LocalShellCallAction = Field(..., description="The shell command to execute.")
    call_id: str = Field(..., description="The unique ID of the tool call generated by the model.")
    status: Literal["in_progress", "completed", "incomplete"] = Field(..., description="The status of the call.")


# --- Function Shell ---


class FunctionShellToolCall(BaseModel):
    type: Literal["shell_call"] = Field(..., description="The type of the output item.")
    call_id: str = Field(..., description="The tool call ID.")
    id: str | None = Field(default=None, description="The unique ID.")
    status: Literal["in_progress", "completed", "incomplete"] | None = Field(default=None, description="The status.")
    model_config = ConfigDict(extra="allow")


# --- Apply Patch ---


class ApplyPatchToolCall(BaseModel):
    type: Literal["apply_patch_call"] = Field(..., description="The type of the output item.")
    call_id: str = Field(..., description="The tool call ID.")
    id: str | None = Field(default=None, description="The unique ID.")
    status: Literal["in_progress", "completed"] = Field(..., description="The status.")
    model_config = ConfigDict(extra="allow")


# --- MCP ---


class McpListToolsTool(BaseModel):
    input_schema: dict[str, Any] = Field(..., description="The JSON schema describing the tool's input.")
    name: str = Field(..., description="The name of the tool.")
    annotations: dict[str, Any] | None = Field(default=None, description="Additional annotations about the tool.")
    description: str | None = Field(default=None, description="The description of the tool.")


class McpListTools(BaseModel):
    type: Literal["mcp_list_tools"] = Field(..., description="The type of the output item.")
    id: str = Field(..., description="The unique ID of the list.")
    server_label: str = Field(..., description="The label of the MCP server.")
    tools: list[McpListToolsTool] = Field(..., description="The tools available on the server.")
    error: str | None = Field(default=None, description="Error message if the server could not list tools.")


class McpApprovalRequest(BaseModel):
    type: Literal["mcp_approval_request"] = Field(..., description="The type of the output item.")
    id: str = Field(..., description="The unique ID of the approval request.")
    arguments: str = Field(..., description="A JSON string of arguments for the tool.")
    name: str = Field(..., description="The name of the tool to run.")
    server_label: str = Field(..., description="The label of the MCP server making the request.")


class McpCall(BaseModel):
    type: Literal["mcp_call"] = Field(..., description="The type of the output item.")
    id: str = Field(..., description="The unique ID of the tool call.")
    arguments: str = Field(..., description="A JSON string of the arguments passed to the tool.")
    name: str = Field(..., description="The name of the tool that was run.")
    server_label: str = Field(..., description="The label of the MCP server running the tool.")
    approval_request_id: str | None = Field(default=None, description="Unique ID for the approval request.")
    error: str | None = Field(default=None, description="The error from the tool call, if any.")
    output: str | None = Field(default=None, description="The output from the tool call.")
    status: Literal["in_progress", "completed", "incomplete", "calling", "failed"] | None = Field(
        default=None, description="The status."
    )


# --- Custom Tool Call (response output) ---


class ResponseCustomToolCall(BaseModel):
    type: Literal["custom_tool_call"] = Field(..., description="The type of the output item.")
    call_id: str = Field(..., description="An identifier used to map this call to output.")
    name: str = Field(..., description="The name of the custom tool being called.")
    input: str = Field(..., description="The input for the custom tool call.")
    id: str | None = Field(default=None, description="The unique ID of the custom tool call.")


# =============================================================================
# ResponseOutputItem union
# =============================================================================

# Note: Using plain union (no discriminator) to allow for dict fallback flexibility
ResponseOutputItem = (
    ResponseOutputMessage
    | FunctionToolCall
    | FileSearchToolCall
    | WebSearchToolCall
    | CodeInterpreterToolCall
    | ComputerToolCall
    | ReasoningItem
    | ImageGenerationCall
    | LocalShellCall
    | FunctionShellToolCall
    | ApplyPatchToolCall
    | McpCall
    | McpListTools
    | McpApprovalRequest
    | ResponseCustomToolCall
    | dict[str, Any]
)

# =============================================================================
# Usage Statistics
# =============================================================================


class InputTokensDetails(BaseModel):
    cached_tokens: int = Field(..., description="The number of tokens that were retrieved from the cache.")


class OutputTokensDetails(BaseModel):
    reasoning_tokens: int = Field(..., description="The number of reasoning tokens.")


class ResponseUsage(BaseModel):
    input_tokens: int = Field(..., description="The number of input tokens.")
    input_tokens_details: InputTokensDetails = Field(..., description="A detailed breakdown of the input tokens.")
    output_tokens: int = Field(..., description="The number of output tokens.")
    output_tokens_details: OutputTokensDetails = Field(..., description="A detailed breakdown of the output tokens.")
    total_tokens: int = Field(..., description="The total number of tokens used.")


# =============================================================================
# Error Types
# =============================================================================


class ResponseError(BaseModel):
    code: str = Field(..., description="The error code.")
    message: str = Field(..., description="A human-readable error message.")


# =============================================================================
# Supporting Info Types
# =============================================================================


class ToolInfo(BaseModel):
    type: str = Field(..., description="The type of the tool.")
    model_config = ConfigDict(extra="allow")


class ConversationInfo(BaseModel):
    id: str = Field(..., description="The unique ID of the conversation.")


class ResponsePromptInfo(BaseModel):
    id: str = Field(..., description="The unique ID of the prompt template.")
    variables: dict[str, str] | None = Field(default=None, description="Variables used in the prompt template.")


class IncompleteDetails(BaseModel):
    reason: Literal["max_output_tokens", "content_filter"] | None = Field(
        default=None, description="The reason why the response is incomplete."
    )


# =============================================================================
# Main Response Class
# =============================================================================


class ResponsesResponse(BaseModel):
    """OpenAI Responses API response object."""

    id: str = Field(..., description="Unique identifier for this Response.")
    object: Literal["response"] = Field(..., description="The object type - always 'response'.")
    created_at: float = Field(..., description="Unix timestamp (in seconds) of when this Response was created.")
    model: str = Field(..., description="Model ID used to generate the response.")
    output: list[ResponseOutputItem] = Field(..., description="An array of content items generated by the model.")
    parallel_tool_calls: bool = Field(..., description="Whether the model can run tool calls in parallel.")
    tool_choice: Literal["none", "auto", "required"] | dict[str, Any] = Field(
        ..., description="How the model should select which tool to use."
    )
    tools: list[ToolInfo] = Field(..., description="An array of tools the model may call.")
    status: Literal["completed", "failed", "in_progress", "cancelled", "queued", "incomplete"] | None = Field(
        default=None, description="The status of the response generation."
    )
    error: ResponseError | None = Field(default=None, description="An error object if the model fails.")
    incomplete_details: IncompleteDetails | None = Field(
        default=None, description="Details about why the response is incomplete."
    )
    instructions: str | list[dict[str, Any]] | None = Field(
        default=None, description="A system (or developer) message."
    )
    metadata: dict[str, str] | None = Field(default=None, description="Key-value pairs for additional information.")
    temperature: float | None = Field(default=None, description="Sampling temperature (0-2).")
    top_p: float | None = Field(default=None, description="Nucleus sampling parameter.")
    background: bool | None = Field(default=None, description="Whether to run in the background.")
    completed_at: float | None = Field(
        default=None, description="Unix timestamp (in seconds) of when this Response was completed."
    )
    conversation: ConversationInfo | None = Field(
        default=None, description="The conversation this response belongs to."
    )
    max_output_tokens: int | None = Field(default=None, description="Upper bound for generated tokens.")
    max_tool_calls: int | None = Field(default=None, description="The maximum number of calls to built-in tools.")
    previous_response_id: str | None = Field(default=None, description="The ID of the previous response.")
    prompt: ResponsePromptInfo | None = Field(default=None, description="Reference to a prompt template.")
    prompt_cache_key: str | None = Field(default=None, description="Used for prompt caching optimization.")
    prompt_cache_retention: Literal["in-memory", "24h"] | None = Field(
        default=None, description="Retention policy for prompt cache."
    )
    reasoning: dict[str, Any] | None = Field(default=None, description="Configuration for reasoning models.")
    safety_identifier: str | None = Field(default=None, description="Identifier for abuse detection.")
    service_tier: Literal["auto", "default", "flex", "scale", "priority"] | None = Field(
        default=None, description="Processing type used for serving the request."
    )
    text: dict[str, Any] | None = Field(default=None, description="Configuration for text response.")
    top_logprobs: int | None = Field(default=None, description="Number of most likely tokens to return (0-20).")
    truncation: Literal["auto", "disabled"] | None = Field(default=None, description="Truncation strategy.")
    usage: ResponseUsage | None = Field(default=None, description="Token usage details.")
    user: str | None = Field(default=None, description="Deprecated: use safety_identifier and prompt_cache_key.")

    session_id: str | None = Field(default=None, description="Sequrity session ID.")

    model_config = ConfigDict(extra="ignore")

    @property
    def output_text(self) -> str:
        """Convenience property that aggregates all output_text items from the output list."""
        texts: list[str] = []
        for item in self.output:
            if isinstance(item, ResponseOutputMessage):
                for content in item.content:
                    if isinstance(content, OutputText):
                        texts.append(content.text)
            elif isinstance(item, dict) and item.get("type") == "message":
                for content in item.get("content", []):
                    if isinstance(content, dict) and content.get("type") == "output_text":
                        texts.append(content.get("text", ""))
        return "".join(texts)
